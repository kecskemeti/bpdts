/*
 *  ========================================================================
 *  BPDTS
 *  ========================================================================
 *  
 *  This file is part of BPDTS.
 *  
 *  BPDTS is free software: you can redistribute it and/or modify it under
 *  the terms of the GNU General Public License as published by the Free
 *  Software Foundation, either version 3 of the License, or (at your option)
 *  any later version.
 *  
 *  BPDTS is distributed in the hope that it will be useful, but WITHOUT ANY
 *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 *  details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with BPDTS.  If not, see <http://www.gnu.org/licenses/>.
 *  
 *  (C) Copyright 2021, Gabor Kecskemeti (kecskemeti@iit.uni-miskolc.hu)
 */

package bpdts;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Consumer;
import java.util.function.Predicate;

import bpdts.gen.ApiException;
import bpdts.gen.model.User;

/**
 * 
 * The main entry point to the client API for the system, allows the setup of
 * the swagger generated client (i.e., customising the service host) as well as
 * the main application behaviour (i.e., city and distance details necessary for
 * API queries). Note that many of the functionalities are actually achieved by
 * code generated by swagger-codegen, here the code only has the glue that holds
 * all the client calls together.
 * 
 * Offers two main ways to interact with the service:
 * <ol>
 * <li>Allows to query all users who are listed to reside in a particular city.
 * See: {@link BpdtsAPI#getUsersOfCity()}</li>
 * <li>Allows to query all users within a predefined distance to a particular
 * city. See: {@link BpdtsAPI#getUsersNearCity()}</li>
 * </ol>
 * 
 * @author Gabor Kecskemeti
 *
 */
public class BpdtsAPI {
	// Internal state:
	private City cityToCheckAgainst;
	private double maxDistanceInMiles;
	private final InjectableClientAPI api;

	// Filtering techniques for acceptable users in streams, first for citizenship,
	// then for distance
	private final Predicate<User> nameChecker = u -> (cityToCheckAgainst.userBelongsToCity(u) == Belonging.CITIZEN);
	private final Predicate<User> distanceChecker = u -> (cityToCheckAgainst.distanceOfUser(u) < maxDistanceInMiles);

	/**
	 * Allows the API to interface with arbitrary service client interfaces and
	 * service locations.
	 * 
	 * @param api      The client service interface to be used
	 * @param basePath The service's location where the client needs to communicate.
	 */
	public BpdtsAPI(final InjectableClientAPI api, final String basePath) {
		api.getApiClient().setBasePath(basePath);
		this.api = api;
	}

	/**
	 * Simplifies the API's creation by opting to use the default
	 * swagger-codegen-generated
	 * 
	 * @param basePath Where is the service to talk to? (URL!)
	 */
	public BpdtsAPI(final String basePath) {
		this(new DefaultClientAPI(), basePath);
	}

	/**
	 * Allows the querying of the city configured for the API calls.
	 * 
	 * @return
	 */
	public City getCityToCheckAgainst() {
		return cityToCheckAgainst;
	}

	/**
	 * Allows changing the city configured for the API calls.
	 * 
	 */
	public void setCityToCheckAgainst(final City cityToCheckAgainst) {
		this.cityToCheckAgainst = cityToCheckAgainst;
	}

	/**
	 * Allows the querying of the farthest distance that should be still considered
	 * close to a particular city during API calls.
	 * 
	 * @return distance in miles
	 */
	public double getMaxDistanceInMiles() {
		return maxDistanceInMiles;
	}

	/**
	 * Allows changing the farthest distance that should be still considered close
	 * to a particular city during API calls.
	 * 
	 * @param maxDistanceInMiles The acceptable distance specified in miles.
	 */
	public void setMaxDistanceInMiles(final double maxDistanceInMiles) {
		this.maxDistanceInMiles = maxDistanceInMiles;
	}

	/**
	 * Helper function that allows customisable filtering actions to be executed
	 * around basic exception and collection management.
	 * 
	 * @param action The actual task to do which will populate a hashset based on
	 *               its own criteria. Note a hashset is used so it does not allow
	 *               the same user to be listed multiple times.
	 * @return The list of users who meet the criteria
	 * @throws ApiException In case of networking issues
	 */
	private List<User> doFiltering(final Consumer<Set<User>> action) throws ApiException {
		var filtered = new TreeSet<User>(new Comparator<User>() {
			@Override
			public int compare(User u0, User u1) {
				return Integer.compare(u0.getId(), u1.getId());
			}
		});
		if (cityToCheckAgainst != null) {
			try {
				action.accept(filtered);
			} catch (RuntimeException rex) {
				if (rex.getCause() instanceof ApiException) {
					throw (ApiException) rex.getCause();
				}
				// This is just a regular runtime exception, it must be passed further on as
				// this is very unexpected
				throw rex;
			}
		}
		return Collections.unmodifiableList(new ArrayList<>(filtered));
	}

	/**
	 * Helper method to allow customisable filtering of user lists returned by the
	 * service.
	 * 
	 * @param filtered The set that contains the users from all users who match the
	 *                 specified criterion
	 * @param checker  What filtering condition should we use to determine what
	 *                 users should be added to the filtered set
	 * @throws ApiException In case of networking issues.
	 */
	private void userStreamFilter(final Set<User> filtered, final Predicate<User> checker) throws ApiException {
		api.getUsers().stream().filter(checker).forEach(filtered::add);
	}

	/**
	 * A filtering action that focuses on the city field of users and tries to match
	 * it against the city name in the internal state
	 * 
	 * @param filtered The set of users to populate based on the filtering condition
	 */
	private void usersOfCity(final Set<User> filtered) {
		try {
			filtered.addAll(api.getCityUsers(cityToCheckAgainst.name));
			userStreamFilter(filtered, nameChecker);
		} catch (ApiException ae) {
			throw new RuntimeException(ae);
		}
	}

	/**
	 * A filtering action that focuses on the distance between the city's perimeter
	 * and the user's current location.
	 * 
	 * @param filtered The set of users to populate based on the filtering condition
	 */
	private void usersAround(final Set<User> filtered) {
		try {
			userStreamFilter(filtered, distanceChecker);
		} catch (ApiException ae) {
			throw new RuntimeException(ae);
		}
	}

	/**
	 * One of the public facing parts of the API. Before calling this, please set up
	 * the expected city the users should be citizens of with the method
	 * {@link #setCityToCheckAgainst(City)}
	 * 
	 * This method will make a service invocation through the swagger-codegen
	 * generated api to the external service (located at the url specified during
	 * the API's instantiation).
	 * 
	 * @return The list of users who belong to the city specified earlier.
	 * @throws ApiException If there was a networking error.
	 */
	public List<User> getUsersOfCity() throws ApiException {
		return doFiltering(this::usersOfCity);
	}

	/***
	 * The second public facing part of the API. Before calling this, please set up
	 * the expected city the users should be near to with the method
	 * {@link #setCityToCheckAgainst(City)}. You should also specify what is the
	 * maximum acceptable distance that can still be considered near with the method
	 * {@link #setMaxDistanceInMiles(double)}.
	 * 
	 * This method will make a service invocation through the swagger-codegen
	 * generated api to the external service (located at the url specified during
	 * the API's instantiation).
	 * 
	 * @return The list of users who are within the specified miles to the perimeter
	 *         of the specified city.
	 * @throws ApiException In case network errors occur.
	 */
	public List<User> getUsersNearCity() throws ApiException {
		return doFiltering(this::usersAround);
	}
}
